#!/bin/bash

# Claude Code Post-Tool-Call Hook
# Automatically updates agent context based on tool usage and results

set -e

TOOL_NAME="$1"
TOOL_RESULT="$2"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
PROJECT_ROOT="/home/coder/convex-coder"

cd "$PROJECT_ROOT"

# Get current agent if one is active
CURRENT_AGENT=""
if [[ -f ".claude/current-agent" ]]; then
    CURRENT_AGENT=$(cat .claude/current-agent 2>/dev/null || echo "")
fi

# Function to extract command from tool arguments
extract_command() {
    local tool_name="$1"
    local tool_result="$2"
    
    case "$tool_name" in
        "Bash")
            # Extract the actual command from bash tool result
            echo "$tool_result" | grep -o "Command: .*" | head -1 | sed 's/Command: //' || echo "bash command"
            ;;
        "Edit"|"Write"|"MultiEdit")
            echo "$tool_name operation on file"
            ;;
        "Read")
            echo "file read operation"
            ;;
        "Glob"|"Grep")
            echo "$tool_name search operation"
            ;;
        *)
            echo "$tool_name operation"
            ;;
    esac
}

# Function to determine if command was successful
is_command_successful() {
    local tool_result="$2"
    
    # Check for common success/failure indicators
    if [[ "$tool_result" =~ "error"|"Error"|"ERROR"|"failed"|"Failed"|"FAILED" ]]; then
        return 1
    elif [[ "$tool_result" =~ "success"|"Success"|"SUCCESS"|"completed"|"Completed"|"✓"|"✅" ]]; then
        return 0
    else
        # If no clear indicator, assume success (most tools succeed by default)
        return 0
    fi
}

# Log all tool usage
echo "[$TIMESTAMP] Tool: $TOOL_NAME" >> .claude/tool-usage.log

# Automatic context updates based on tool usage
case "$TOOL_NAME" in
    "Bash")
        if [[ -n "$CURRENT_AGENT" ]]; then
            COMMAND=$(extract_command "$TOOL_NAME" "$TOOL_RESULT")
            
            if is_command_successful "$TOOL_NAME" "$TOOL_RESULT"; then
                # Command succeeded - record as effective
                ./scripts/update-context.sh "$CURRENT_AGENT" add-effective-command "$COMMAND" 2>/dev/null || true
                echo "✅ Recorded effective command for $CURRENT_AGENT: $COMMAND"
            else
                # Command failed - record as problematic
                ./scripts/update-context.sh "$CURRENT_AGENT" add-problematic-command "$COMMAND" 2>/dev/null || true
                echo "⚠️  Recorded problematic command for $CURRENT_AGENT: $COMMAND"
            fi
        fi
        
        # Special handling for specific commands
        if [[ "$TOOL_RESULT" =~ "npm run test"|"playwright test"|"pnpm test" ]]; then
            # Testing activity detected
            if [[ "$CURRENT_AGENT" != "web-testing-specialist" && -n "$CURRENT_AGENT" ]]; then
                # Update dependencies - this agent works with testing
                echo "🔗 Recording testing dependency for $CURRENT_AGENT"
                ./scripts/update-context.sh "$CURRENT_AGENT" update-state "Works with web-testing-specialist for validation" 2>/dev/null || true
            fi
        fi
        
        if [[ "$TOOL_RESULT" =~ "convex dev"|"convex deploy"|"convex push" ]]; then
            # Convex activity detected
            echo "🔄 Convex activity detected"
            if [[ -n "$CURRENT_AGENT" ]]; then
                ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Used Convex CLI successfully" 2>/dev/null || true
            fi
        fi
        ;;
        
    "Edit"|"Write"|"MultiEdit")
        if [[ -n "$CURRENT_AGENT" ]]; then
            # File modification detected
            if is_command_successful "$TOOL_NAME" "$TOOL_RESULT"; then
                ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Successfully modified files using $TOOL_NAME" 2>/dev/null || true
                echo "📝 Recorded file modification success for $CURRENT_AGENT"
            else
                echo "⚠️  File modification issues detected for $CURRENT_AGENT"
            fi
        fi
        ;;
        
    "Read")
        # File reading is usually for research/understanding
        if [[ -n "$CURRENT_AGENT" ]]; then
            echo "📖 File reading activity for $CURRENT_AGENT"
        fi
        ;;
        
    "Glob"|"Grep")
        if [[ -n "$CURRENT_AGENT" ]]; then
            SEARCH_OP=$(extract_command "$TOOL_NAME" "$TOOL_RESULT")
            if is_command_successful "$TOOL_NAME" "$TOOL_RESULT"; then
                ./scripts/update-context.sh "$CURRENT_AGENT" add-effective-command "$SEARCH_OP" 2>/dev/null || true
                echo "🔍 Recorded effective search for $CURRENT_AGENT"
            fi
        fi
        ;;
        
    "TodoWrite")
        # Task management activity
        echo "📋 Task management activity detected"
        if [[ -n "$CURRENT_AGENT" ]]; then
            ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Used TodoWrite for task tracking" 2>/dev/null || true
        fi
        ;;
esac

# Performance and error tracking
track_performance() {
    local tool_name="$1"
    local tool_result="$2"
    
    # Extract timing information if available
    if [[ "$tool_result" =~ "took [0-9]+.*ms"|"completed in [0-9]+.*s" ]]; then
        echo "📊 Performance data available for $tool_name"
        if [[ -n "$CURRENT_AGENT" && "$CURRENT_AGENT" == "performance-engineer" ]]; then
            ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Performance timing: $tool_name" 2>/dev/null || true
        fi
    fi
    
    # Track memory usage if available
    if [[ "$tool_result" =~ "memory"|"Memory"|"MB"|"GB" ]]; then
        echo "🧠 Memory usage data for $tool_name"
        if [[ -n "$CURRENT_AGENT" && "$CURRENT_AGENT" == "performance-engineer" ]]; then
            ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Memory data: $tool_name" 2>/dev/null || true
        fi
    fi
}

track_performance "$TOOL_NAME" "$TOOL_RESULT"

# Agent-specific intelligence
case "$CURRENT_AGENT" in
    "web-testing-specialist")
        # Track testing-specific patterns
        if [[ "$TOOL_NAME" == "Bash" && "$TOOL_RESULT" =~ "playwright"|"test" ]]; then
            if [[ "$TOOL_RESULT" =~ "passed"|"✓" ]]; then
                ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Tests passed successfully" 2>/dev/null || true
            elif [[ "$TOOL_RESULT" =~ "failed"|"✗" ]]; then
                ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Test failures encountered - may need investigation" 2>/dev/null || true
            fi
        fi
        ;;
        
    "convex-function-generator")
        # Track Convex function development
        if [[ "$TOOL_NAME" =~ "Edit"|"Write" && "$TOOL_RESULT" =~ "convex/" ]]; then
            ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Modified Convex function files" 2>/dev/null || true
        fi
        ;;
        
    "react-convex-builder")
        # Track React component work
        if [[ "$TOOL_NAME" =~ "Edit"|"Write" && "$TOOL_RESULT" =~ "components/"|".tsx"|".jsx" ]]; then
            ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Modified React component files" 2>/dev/null || true
        fi
        ;;
esac

# Quality gates and validation
validate_project_health() {
    # Only run validation checks after significant changes
    if [[ "$TOOL_NAME" =~ "Edit"|"Write"|"MultiEdit" ]]; then
        
        # Check if we should run type checking
        if command -v npm >/dev/null 2>&1 && [[ -f "package.json" ]]; then
            # Don't block the workflow, but record if type checking would fail
            if npm run typecheck >/dev/null 2>&1; then
                echo "✅ Type check still passes after changes"
            else
                echo "⚠️  Type check issues detected after changes"
                if [[ -n "$CURRENT_AGENT" ]]; then
                    ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Recent changes may have introduced type errors" 2>/dev/null || true
                fi
            fi
        fi
    fi
}

# Run validation in background to not slow down the workflow
validate_project_health &

# Context learning from patterns
learn_from_patterns() {
    local tool_name="$1"
    local tool_result="$2"
    
    # Learn from successful file operations
    if [[ "$tool_name" =~ "Edit"|"Write" && "$tool_result" =~ "successfully" ]]; then
        if [[ -n "$CURRENT_AGENT" ]]; then
            ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "File operations are working smoothly" 2>/dev/null || true
        fi
    fi
    
    # Learn from search operations  
    if [[ "$tool_name" =~ "Glob"|"Grep" && "$tool_result" =~ "found"|"matches" ]]; then
        if [[ -n "$CURRENT_AGENT" ]]; then
            ./scripts/update-context.sh "$CURRENT_AGENT" add-learning "Search operations are effective in this project" 2>/dev/null || true
        fi
    fi
}

learn_from_patterns "$TOOL_NAME" "$TOOL_RESULT"

# Update agent state periodically
update_agent_state() {
    if [[ -n "$CURRENT_AGENT" ]]; then
        # Count recent tool usage for this agent
        local recent_tools=$(tail -n 10 .claude/tool-usage.log | wc -l)
        if [[ $recent_tools -gt 5 ]]; then
            ./scripts/update-context.sh "$CURRENT_AGENT" update-state "Active work session - $recent_tools recent tool calls" 2>/dev/null || true
        fi
    fi
}

# Update state every few tool calls
if [[ $((RANDOM % 5)) -eq 0 ]]; then
    update_agent_state
fi

# Exit successfully
exit 0